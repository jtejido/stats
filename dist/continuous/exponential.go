package continuous

import (
	"github.com/jtejido/linear"
	"github.com/jtejido/stats"
	"github.com/jtejido/stats/err"
	"math"
	"math/rand"
)

// Exponential distribution
// https://en.wikipedia.org/wiki/Exponential_distribution
type Exponential struct {
	baseContinuousWithSource
	rate    float64
	natural linear.RealVector
}

func NewExponential(rate float64) (*Exponential, error) {
	return NewExponentialWithSource(rate, nil)
}

func NewExponentialWithSource(rate float64, src rand.Source) (*Exponential, error) {
	if rate <= 0 {
		return nil, err.Invalid()
	}

	r := new(Exponential)
	r.rate = rate
	r.src = src

	return r, nil
}

func (e *Exponential) String() string {
	return "Exponential: Parameters - " + e.Parameters().String() + ", Support(x) - " + e.Support().String()
}

// λ ∈ (0,∞)
func (e *Exponential) Parameters() stats.Limits {
	return stats.Limits{
		"λ": stats.Interval{0, math.Inf(1), true, true},
	}
}

// x ∈ [0,∞)
func (e *Exponential) Support() stats.Interval {
	return stats.Interval{0, math.Inf(1), false, true}
}

func (e *Exponential) Probability(x float64) float64 {
	if e.Support().IsWithinInterval(x) {
		return e.rate * math.Exp(-e.rate*x)
	}

	return 0
}

func (e *Exponential) Distribution(x float64) float64 {
	if e.Support().IsWithinInterval(x) {
		return 1 - math.Exp(-e.rate*x)
	}

	return 0
}

func (e *Exponential) Entropy() float64 {
	return 1 - math.Log(e.rate)
}

func (e *Exponential) ExKurtosis() float64 {
	return 6
}

func (e *Exponential) Skewness() float64 {
	return 2
}

func (e *Exponential) Inverse(p float64) float64 {
	if p <= 0 {
		return 0
	}

	if p >= 1 {
		return math.Inf(1)
	}

	return -math.Log(1-p) / e.rate

}

func (e *Exponential) Mean() float64 {
	return 1 / e.rate
}

func (e *Exponential) Median() float64 {
	return math.Log(2) / e.rate
}

func (e *Exponential) Mode() float64 {
	return 0
}

func (e *Exponential) Variance() float64 {
	return 1 / (e.rate * e.rate)
}

func (e *Exponential) Rand() float64 {
	// T = F^-1(U)
	// U is uniform on (0, 1), so is 1 − U.
	// return (-math.Log(rnd.Float64())) / e.rate
	return e.rand() / e.rate
}

// McFarland, C.D. A modified ziggurat algorithm for generating exponentially and normally distributed pseudorandom numbers. 2014.
func (e *Exponential) rand() float64 {
	var r63 func() int64
	if e.src != nil {
		r63 = rand.New(e.src).Int63
	} else {
		r63 = rand.Int63
	}

	i := r63() & 0xff /* Float multiplication squashes these last 8 bits, so they can be used to sample i */
	if i < 252 {
		return exp_X[i] * float64(r63()&0x7fffffffffffffff)
	} /* Early Exit */

	j := e.exp_sample_A(r63)
	X_0 := 7.56927469415 /* Beginning of tail */
	if j > 0 {           /* sample from tail if j == 0; otherwise sample the overhang j */
		return e.exp_overhang(r63, j)
	}

	return X_0 + e.Rand()
}

func (e *Exponential) exp_sample_A(r63 func() int64) uint {
	/* Alias Sampling, see http://scorevoting.net/WarrenSmithPages/homepage/sampling.abs */
	m := [256]uint{0, 0, 1, 235, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 250, 250, 250, 250, 250, 250, 250, 249, 249, 249, 249, 249, 249, 248, 248, 248, 248, 247, 247, 247, 247, 246, 246, 246, 245, 245, 244, 244, 243, 243, 242, 241, 241, 240, 239, 237, 3, 3, 4, 4, 6, 0, 0, 0, 0, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 2, 0, 0, 0}
	ipmf := [256]int64{9223372036854775328, 1623796909450838420, 2664290944894293715, 7387971354164060121, 6515064486552739054, 8840508362680717952, 6099647593382935246, 7673130333659513959, 6220332867583438265, 5045979640552813853, 4075305837223955667, 3258413672162525563, 2560664887087762661, 1957224924672899759, 1429800935350577626, 964606309710808357, 551043923599587249, 180827629096890397, -152619738120023526, -454588624410291449, -729385126147774875, -980551509819446846, -1211029700667463872, -1423284293868547154, -1619396356369050292, -1801135830956212822, -1970018048575618008, -2127348289059705241, -2274257249303686299, -2411729520096655228, -2540626634159182525, -2661705860113406462, -2775635634532448735, -2883008316030465121, -2984350790383654722, -3080133339198118434, -3170777096303091107, -3256660348483804932, -3338123885075152741, -3415475560473282822, -3488994201966444710, -3558932970354470759, -3625522261068041096, -3688972217741992040, -3749474917563782729, -3807206277531056234, -3862327722496827274, -3914987649156779787, -3965322714631865323, -4013458973776912076, -4059512885612767084, -4103592206186241133, -4145796782586128173, -4186219260694363437, -4224945717447258894, -4262056226866285614, -4297625367836519694, -4331722680528537423, -4364413077437472623, -4395757214229418223, -4425811824915119504, -4454630025296932688, -4482261588141311280, -4508753193105271888, -4534148654077804689, -4558489126279970065, -4581813295192216657, -4604157549138257681, -4625556137145250418, -4646041313519109426, -4665643470413305970, -4684391259530326642, -4702311703971761747, -4719430301145086931, -4735771117539946355, -4751356876102103699, -4766209036859128403, -4780347871386013331, -4793792531638892019, -4806561113635122292, -4818670716409312756, -4830137496634465780, -4840976719260854452, -4851202804490332660, -4860829371376460084, -4869869278311657652, -4878334660640771092, -4886236965617427412, -4893586984900802772, -4900394884772702964, -4906670234238885493, -4912422031164489589, -4917658726580136309, -4922388247283532373, -4926618016851059029, -4930354975163335189, -4933605596540651285, -4936375906575303797, -4938671497741365845, -4940497543854575637, -4941858813449629493, -4942759682136114997, -4943204143989086773, -4943195822025527893, -4942737977813206357, -4941833520255033237, -4940485013586738773, -4938694684624359381, -4936464429291795925, -4933795818458825557, -4930690103114057941, -4927148218896868949, -4923170790008275925, -4918758132519202261, -4913910257091645845, -4908626871126550421, -4902907380349522964, -4896750889844289364, -4890156204540514772, -4883121829162554452, -4875645967641803284, -4867726521994894420, -4859361090668136340, -4850546966345097428, -4841281133215539220, -4831560263698486164, -4821380714613453652, -4810738522790066260, -4799629400105482131, -4788048727936313747, -4775991551010508883, -4763452570642098131, -4750426137329511059, -4736906242696389331, -4722886510751361491, -4708360188440098835, -4693320135461437394, -4677758813316075410, -4661668273553512594, -4645040145179234642, -4627865621182772242, -4610135444140937425, -4591839890849345681, -4572968755929937937, -4553511334358205905, -4533456402849118097, -4512792200036279121, -4491506405372581072, -4469586116675402576, -4447017826233108176, -4423787395382268560, -4399880027458432847, -4375280239014115151, -4349971829190464271, -4323937847117722127, -4297160557210950158, -4269621402214950094, -4241300963840749518, -4212178920821845518, -4182234004204468173, -4151443949668868493, -4119785446662289613, -4087234084103201932, -4053764292396157324, -4019349281473091724, -3983960974549676683, -3947569937258407435, -3910145301787369227, -3871654685619016074, -3832064104425399050, -3791337878631545353, -3749438533114317833, -3706326689447995081, -3661960950051848712, -3616297773528535240, -3569291340409179143, -3520893408440946503, -3471053156460654726, -3419717015797782918, -3366828488034800645, -3312327947826472069, -3256152429334011012, -3198235394669703364, -3138506482563184963, -3076891235255163586, -3013310801389731586, -2947681612411375617, -2879915029671665601, -2809916959107518656, -2737587429961872959, -2662820133571326270, -2585501917733374398, -2505512231579382333, -2422722515205206076, -2336995527534112187, -2248184604988688954, -2156132842510798521, -2060672187261006776, -1961622433929382455, -1858790108950092598, -1751967229002903349, -1640929916937143604, -1525436855617592627, -1405227557075244850, -1280020420662660017, -1149510549536587824, -1013367289578705710, -871231448632088621, -722712146453685035, -567383236774420522, -404779231966955560, -234390647591522471, -55658667960120229, 132030985907824093, 329355128892810847, 537061298001092449, 755977262693571427, 987022116608031845, 1231219266829421544, 1489711711346525930, 1763780090187560429, 2054864117341776240, 2364588157623792755, 2694791916990483702, 3047567482883492729, 3425304305830814717, 3830744187097279873, 4267048975685831301, 4737884547990035082, 5247525842198997007, 5800989391535354004, 6404202162993293978, 7064218894258529185, 7789505049452340392, 8590309807749443504, 7643763810684498323, 8891950541491447639, 5457384281016226081, 9083704440929275131, 7976211653914439517, 8178631350487107662, 2821287825726743868, 6322989683301723979, 4309503753387603546, 4685170734960182655, 8404845967535219911, 7330522972447586582, 1960945799077017972, 4742910674644930459, -751799822533465632, 7023456603741994979, 3843116882594690323, 3927231442413903597, -9223372036854775807, -9223372036854775807, -9223372036854775807}
	j := uint(r63()) & 0xff /* j <- I(0, 256) */
	if r63() >= ipmf[j] {
		return m[j]
	}

	return j
}

func (e *Exponential) exp_overhang(r63 func() int64, j uint) float64 { /* Draws a PRN from overhang i */

	U_x := r63()              /* To sample a unit right-triangle: */
	U_distance := r63() - U_x /* U_x <- min(U_1, U_2)             */
	if U_distance < 0 {       /* distance <- | U_1 - U_2 |        */
		U_distance = -U_distance /* U_y <- 1 - (U_x + distance)      */
		U_x -= U_distance
	}

	x := fast_sample_x(j, U_x)
	if U_distance >= 853965788476313646 { // eps max
		return x
	} /* Early Exit: x < y - epsilon */
	if fast_sample_y(j, math.MaxInt64-(U_x+U_distance)) <= math.Exp(-x) {
		return x
	}

	return e.exp_overhang(r63, j)

}

func fast_sample_x(j uint, U int64) float64 {
	return exp_X[j]*(1<<63-1) + (exp_X[j-1]-exp_X[j])*float64(U)
}
func fast_sample_y(i uint, U int64) float64 {
	return exp_Y[i-1]*(1<<63-1) + (exp_Y[i]-exp_Y[i-1])*float64(U)
}

func (e *Exponential) ToExponential() {
	vec, _ := linear.NewArrayRealVectorFromSlice([]float64{-e.rate})
	e.natural = vec

	// vec2, _ := linear.NewSizedArrayRealVector(1)
	// vec2.SetEntry(0, 1/e.rate)
	// e.Moment = vec2
}

func (e *Exponential) SufficientStatistics(x float64) linear.RealVector {
	vec, _ := linear.NewArrayRealVectorFromSlice([]float64{x})
	return vec
}
